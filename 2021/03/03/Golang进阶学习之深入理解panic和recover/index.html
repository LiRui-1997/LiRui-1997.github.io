<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Golang进阶学习之深入理解panic和recover | 李瑞的个人博客</title><meta name="description" content="什么是 Panic ？在 Go 语言中，程序中一般是使用错误来处理异常情况。对于程序中出现的大部分异常情况，错误就已经够用了。 但在有些情况，当程序发生异常时，无法继续运行。在这种情况下，我们会使用 panic 来终止程序。当函数发生 panic 时，它会终止运行，在执行完所有的defer函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打"><meta name="keywords" content="golang,panic,recover,异常"><meta name="author" content="李瑞"><meta name="copyright" content="李瑞"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lirui-1997.github.io/2021/03/03/Golang%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3panic%E5%92%8Crecover/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Golang进阶学习之深入理解panic和recover"><meta property="og:url" content="https://lirui-1997.github.io/2021/03/03/Golang%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3panic%E5%92%8Crecover/"><meta property="og:site_name" content="李瑞的个人博客"><meta property="og:description" content="什么是 Panic ？在 Go 语言中，程序中一般是使用错误来处理异常情况。对于程序中出现的大部分异常情况，错误就已经够用了。 但在有些情况，当程序发生异常时，无法继续运行。在这种情况下，我们会使用 panic 来终止程序。当函数发生 panic 时，它会终止运行，在执行完所有的defer函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/image/封面/微信图片_20200922105439.png"><meta property="article:published_time" content="2021-03-03T10:57:38.000Z"><meta property="article:modified_time" content="2021-03-05T03:39:52.548Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-03-05 11:39:52'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/StaticFile_Hexo-master/butterfly/css/pool.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/StaticFile_Hexo-master/butterfly/css/iconfont.min.css"><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">30</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Panic-%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是 Panic ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-panic-%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么时候应该使用 panic ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recover"><span class="toc-number">3.</span> <span class="toc-text">Recover</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">深入思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C"><span class="toc-number">4.1.</span> <span class="toc-text">为什么会终止运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C"><span class="toc-number">4.2.</span> <span class="toc-text">为什么不会终止运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%AE%BE%E7%BD%AE-defer-%E8%A1%8C%E4%B8%8D"><span class="toc-number">4.3.</span> <span class="toc-text">不设置 defer 行不</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E4%B8%8A-goroutine-%E5%B0%B1%E4%B8%8D%E8%A1%8C"><span class="toc-number">4.4.</span> <span class="toc-text">为什么加上 goroutine 就不行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%90%E6%85%8C-panic"><span class="toc-number">5.2.</span> <span class="toc-text">恐慌 panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E6%81%A2%E5%A4%8D%E7%9A%84%E6%81%90%E6%85%8C-fatalpanic"><span class="toc-number">5.3.</span> <span class="toc-text">无法恢复的恐慌 fatalpanic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D-recover"><span class="toc-number">5.4.</span> <span class="toc-text">恢复 recover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">5.5.</span> <span class="toc-text">拓展</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/image/封面/微信图片_20200922105439.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">李瑞的个人博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Golang进阶学习之深入理解panic和recover</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-03T10:57:38.000Z" title="发表于 2021-03-03 18:57:38">2021-03-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-05T03:39:52.548Z" title="更新于 2021-03-05 11:39:52">2021-03-05</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="什么是-Panic-？"><a href="#什么是-Panic-？" class="headerlink" title="什么是 Panic ？"></a>什么是 Panic ？</h2><p>在 Go 语言中，程序中一般是使用错误来处理异常情况。对于程序中出现的大部分异常情况，错误就已经够用了。</p>
<p>但在有些情况，当程序发生异常时，无法继续运行。在这种情况下，我们会使用 <code>panic</code> 来终止程序。当函数发生 panic 时，它会终止运行，在执行完所有的defer函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪（Stack Trace），最后程序终止。</p>
<h2 id="什么时候应该使用-panic-？"><a href="#什么时候应该使用-panic-？" class="headerlink" title="什么时候应该使用 panic ？"></a>什么时候应该使用 panic ？</h2><p>需要注意的是，你应该尽可能地使用错误，而不是使用 panic 和 recover。只有当程序不能继续运行的时候，才应该使用 panic 和 recover 机制。</p>
<p>panic 有两个合理的用例：</p>
<ol>
<li><strong>发生了一个不能恢复的错误，此时程序不能继续运行。 一个例子就是 web 服务器无法绑定所要求的端口。在这种情况下，就应该使用 panic，因为如果不能绑定端口，啥也做不了。</strong></li>
<li><strong>发生了一个编程上的错误。 假如我们有一个接收指针参数的方法，而其他人使用 <code>nil</code> 作为参数调用了它。在这种情况下，我们可以使用 panic，因为这是一个编程错误：用 <code>nil</code> 参数调用了一个只能接收合法指针的方法。</strong></li>
</ol>
<h2 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h2><p><code>recover</code> 是一个内建函数，用于重新获得 panic 协程的控制。</p>
<p>只有在延迟函数的内部，调用 <code>recover</code> 才有用。在延迟函数内调用 <code>recover</code>，可以取到 <code>panic</code> 的错误信息，并且停止 panic 续发事件（Panicking Sequence），程序运行恢复正常。如果在延迟函数的外部调用 <code>recover</code>，就不能停止 panic 续发事件。同时，只有在相同的 Go协程中调用 recover 才管用。<code>recover</code> 不能恢复一个不同协程的 panic。</p>
<h2 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h2><h3 id="为什么会终止运行"><a href="#为什么会终止运行" class="headerlink" title="为什么会终止运行"></a>为什么会终止运行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;EDDYCJY.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go</span></span><br><span class="line">panic: EDDYCJY.</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    /Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:4 +0x39</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>请思考一下，为什么执行 <code>panic</code> 后会导致应用程序运行中止？（而不是单单说执行了 <code>panic</code> 所以就结束了这么含糊）</p>
<h3 id="为什么不会终止运行"><a href="#为什么不会终止运行" class="headerlink" title="为什么不会终止运行"></a>为什么不会终止运行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;recover: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;EDDYCJY.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go </span></span><br><span class="line">2019/05/11 23:39:47 recover: EDDYCJY.</span><br></pre></td></tr></table></figure>

<p>请思考一下，为什么加上 <code>defer</code> + <code>recover</code> 组合就可以保护应用程序？</p>
<h3 id="不设置-defer-行不"><a href="#不设置-defer-行不" class="headerlink" title="不设置 defer 行不"></a>不设置 defer 行不</h3><p>上面问题二是 <code>defer</code> + <code>recover</code> 组合，那我去掉 <code>defer</code> 是不是也可以呢？如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;recover: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;EDDYCJY.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go</span></span><br><span class="line">panic: EDDYCJY.</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    /Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:10 +0xa1</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>请思考一下，为什么需要设置 <code>defer</code> 后 <code>recover</code> 才能起作用？</p>
<h3 id="为什么加上-goroutine-就不行"><a href="#为什么加上-goroutine-就不行" class="headerlink" title="为什么加上 goroutine 就不行"></a>为什么加上 goroutine 就不行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">&quot;recover: %v&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;EDDYCJY.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go </span></span><br><span class="line">panic: EDDYCJY.</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    /Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:14 +0x51</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>请思考一下，为什么新起了一个 <code>Goroutine</code> 就无法捕获到异常了？到底发生了什么事…</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>接下来我们将带着上述几个问题，开始对源码的剖析和分析，尝试从阅读源码中找到思考题的答案和更多为什么。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">    argp      unsafe.Pointer</span><br><span class="line">    arg       <span class="keyword">interface</span>&#123;&#125; </span><br><span class="line">    link      *_panic </span><br><span class="line">    recovered <span class="keyword">bool</span></span><br><span class="line">    aborted   <span class="keyword">bool</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>panic</code> 中是使用 <code>_panic</code> 作为其基础单元的，每执行一次 <code>panic</code> 语句，都会创建一个 <code>_panic</code>。它包含了一些基础的字段用于存储当前的 <code>panic</code> 调用情况，涉及的字段如下：</p>
<ul>
<li>argp：指向 <code>defer</code> 延迟调用的参数的指针</li>
<li>arg：<code>panic</code> 的原因，也就是调用 <code>panic</code> 时传入的参数</li>
<li>link：指向上一个调用的 <code>_panic</code></li>
<li>recovered：<code>panic</code> 是否已经被处理，也就是是否被 <code>recover</code></li>
<li>aborted：<code>panic</code> 是否被中止</li>
</ul>
<p>另外通过查看 <code>link</code> 字段，可得知其是一个链表的数据结构，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/image/Golang%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3panic%E5%92%8Crecover/image-20210303191753370.png" alt="image-20210303191753370.png"></p>
<h3 id="恐慌-panic"><a href="#恐慌-panic" class="headerlink" title="恐慌 panic"></a>恐慌 panic</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;EDDYCJY.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go</span></span><br><span class="line">panic: EDDYCJY.</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">    /Users/eddycjy/go/src/github.com/EDDYCJY/awesomeProject/main.go:4 +0x39</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>我们去反查一下 <code>panic</code> 处理具体逻辑的地方在哪，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool compile -S main.go</span></span><br><span class="line">&quot;&quot;.main STEXT size=66 args=0x0 locals=0x18</span><br><span class="line">    0x0000 00000 (main.go:23)    TEXT    &quot;&quot;.main(SB), ABIInternal, $24-0</span><br><span class="line">    0x0000 00000 (main.go:23)    MOVQ    (TLS), CX</span><br><span class="line">    0x0009 00009 (main.go:23)    CMPQ    SP, 16(CX)</span><br><span class="line">    ...</span><br><span class="line">    0x002f 00047 (main.go:24)    PCDATA    $2, $0</span><br><span class="line">    0x002f 00047 (main.go:24)    MOVQ    AX, 8(SP)</span><br><span class="line">    0x0034 00052 (main.go:24)    CALL    runtime.gopanic(SB)</span><br></pre></td></tr></table></figure>

<p>显然汇编代码直指内部实现是 <code>runtime.gopanic</code>，我们一起来看看这个方法做了什么事，如下（省略了部分）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopanic</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> p _panic</span><br><span class="line">    p.arg = e</span><br><span class="line">    p.link = gp._panic</span><br><span class="line">    gp._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        d := gp._defer</span><br><span class="line">        <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// defer...</span></span><br><span class="line">        ...</span><br><span class="line">        d._panic = (*_panic)(noescape(unsafe.Pointer(&amp;p)))</span><br><span class="line"></span><br><span class="line">        p.argp = unsafe.Pointer(getargp(<span class="number">0</span>))</span><br><span class="line">        reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span><br><span class="line">        p.argp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// recover...</span></span><br><span class="line">        <span class="keyword">if</span> p.recovered &#123;</span><br><span class="line">            ...</span><br><span class="line">            mcall(recovery)</span><br><span class="line">            throw(<span class="string">&quot;recovery failed&quot;</span>) <span class="comment">// mcall should not return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preprintpanics(gp._panic)</span><br><span class="line"></span><br><span class="line">    fatalpanic(gp._panic) <span class="comment">// should not return</span></span><br><span class="line">    *(*<span class="keyword">int</span>)(<span class="literal">nil</span>) = <span class="number">0</span>      <span class="comment">// not reached</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取指向当前 <code>Goroutine</code> 的指针</li>
<li>初始化一个 <code>panic</code> 的基本单位 <code>_panic</code> 用作后续的操作</li>
<li>获取当前 <code>Goroutine</code> 上挂载的 <code>_defer</code>（数据结构也是链表）</li>
<li>若当前存在 <code>defer</code> 调用，则调用 <code>reflectcall</code> 方法去执行先前 <code>defer</code> 中延迟执行的代码，若在执行过程中需要运行 <code>recover</code> 将会调用 <code>gorecover</code> 方法</li>
<li>结束前，使用 <code>preprintpanics</code> 方法打印出所涉及的 <code>panic</code> 消息</li>
<li>最后调用 <code>fatalpanic</code> 中止应用程序，实际是执行 <code>exit(2)</code> 进行最终退出行为的</li>
</ul>
<p>通过对上述代码的执行分析，可得知 <code>panic</code> 方法实际上就是处理当前 <code>Goroutine(g)</code> 上所挂载的 <code>._panic</code> 链表（所以无法对其他 <code>Goroutine</code> 的异常事件响应），然后对其所属的 <code>defer</code> 链表和 <code>recover</code> 进行检测并处理，最后调用退出命令中止应用程序。</p>
<h3 id="无法恢复的恐慌-fatalpanic"><a href="#无法恢复的恐慌-fatalpanic" class="headerlink" title="无法恢复的恐慌 fatalpanic"></a>无法恢复的恐慌 fatalpanic</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fatalpanic</span><span class="params">(msgs *_panic)</span></span> &#123;</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    sp := getcallersp()</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">var</span> docrash <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> startpanic_m() &amp;&amp; msgs != <span class="literal">nil</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            printpanics(msgs)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        docrash = dopanic_m(gp, pc, sp)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        exit(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    *(*<span class="keyword">int</span>)(<span class="literal">nil</span>) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到在异常处理的最后会执行该方法，似乎它承担了所有收尾工作。实际呢，它是在最后对程序执行 <code>exit</code> 指令来达到中止运行的作用，但在结束前它会通过 <code>printpanics</code> 递归输出所有的异常消息及参数。代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printpanics</span><span class="params">(p *_panic)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.link != <span class="literal">nil</span> &#123;</span><br><span class="line">        printpanics(p.link)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;panic: &quot;</span>)</span><br><span class="line">    printany(p.arg)</span><br><span class="line">    <span class="keyword">if</span> p.recovered &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; [recovered]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以不要以为所有的异常都能够被 <code>recover</code> 到，实际上像 <code>fatal error</code> 和 <code>runtime.throw</code> 都是无法被 <code>recover</code> 到的，甚至是 oom 也是直接中止程序的，也有反手就给你来个 <code>exit(2)</code> 教做人。因此在写代码时你应该要相对注意些，“恐慌” 是存在无法恢复的场景的。</p>
<h3 id="恢复-recover"><a href="#恢复-recover" class="headerlink" title="恢复 recover"></a>恢复 recover</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;recover: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;EDDYCJY.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go </span></span><br><span class="line">2019/05/11 23:39:47 recover: EDDYCJY.</span><br></pre></td></tr></table></figure>

<p>和预期一致，成功捕获到了异常。但是 <code>recover</code> 是怎么恢复 <code>panic</code> 的呢？再看看汇编代码，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool compile -S main.go</span></span><br><span class="line">&quot;&quot;.main STEXT size=110 args=0x0 locals=0x18</span><br><span class="line">    0x0000 00000 (main.go:5)    TEXT    &quot;&quot;.main(SB), ABIInternal, $24-0</span><br><span class="line">    ...</span><br><span class="line">    0x0024 00036 (main.go:6)    LEAQ    &quot;&quot;.main.func1·f(SB), AX</span><br><span class="line">    0x002b 00043 (main.go:6)    PCDATA    $2, $0</span><br><span class="line">    0x002b 00043 (main.go:6)    MOVQ    AX, 8(SP)</span><br><span class="line">    0x0030 00048 (main.go:6)    CALL    runtime.deferproc(SB)</span><br><span class="line">    ...</span><br><span class="line">    0x0050 00080 (main.go:12)    CALL    runtime.gopanic(SB)</span><br><span class="line">    0x0055 00085 (main.go:12)    UNDEF</span><br><span class="line">    0x0057 00087 (main.go:6)    XCHGL    AX, AX</span><br><span class="line">    0x0058 00088 (main.go:6)    CALL    runtime.deferreturn(SB)</span><br><span class="line">    ...</span><br><span class="line">    0x0022 00034 (main.go:7)    MOVQ    AX, (SP)</span><br><span class="line">    0x0026 00038 (main.go:7)    CALL    runtime.gorecover(SB)</span><br><span class="line">    0x002b 00043 (main.go:7)    PCDATA    $2, $1</span><br><span class="line">    0x002b 00043 (main.go:7)    MOVQ    16(SP), AX</span><br><span class="line">    0x0030 00048 (main.go:7)    MOVQ    8(SP), CX</span><br><span class="line">    ...</span><br><span class="line">    0x0056 00086 (main.go:8)    LEAQ    go.string.&quot;recover: %v&quot;(SB), AX</span><br><span class="line">    ...</span><br><span class="line">    0x0086 00134 (main.go:8)    CALL    log.Printf(SB)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>通过分析底层调用，可得知主要是如下几个方法：</p>
<ul>
<li>runtime.deferproc</li>
<li>runtime.gopanic</li>
<li>runtime.deferreturn</li>
<li>runtime.gorecover</li>
</ul>
<p>在上小节中，我们讲述了简单的流程，<code>gopanic</code> 方法会调用当前 <code>Goroutine</code> 下的 <code>defer</code> 链表，若 <code>reflectcall</code> 执行中遇到 <code>recover</code> 就会调用 <code>gorecover</code> 进行处理，该方法代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gorecover</span><span class="params">(argp <span class="keyword">uintptr</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    p := gp._panic</span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.recovered &amp;&amp; argp == <span class="keyword">uintptr</span>(p.argp) &#123;</span><br><span class="line">        p.recovered = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> p.arg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这代码，看上去挺简单的，核心就是修改 <code>recovered</code> 字段。该字段是用于标识当前 <code>panic</code> 是否已经被 <code>recover</code> 处理。但是这和我们想象的并不一样啊，程序是怎么从 <code>panic</code> 流转回去的呢？是不是在核心方法里处理了呢？我们再看看 <code>gopanic</code> 的代码，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopanic</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// defer...</span></span><br><span class="line">        ...</span><br><span class="line">        pc := d.pc</span><br><span class="line">        sp := unsafe.Pointer(d.sp) <span class="comment">// must be pointer so it gets adjusted during stack copy</span></span><br><span class="line">        freedefer(d)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// recover...</span></span><br><span class="line">        <span class="keyword">if</span> p.recovered &#123;</span><br><span class="line">            atomic.Xadd(&amp;runningPanicDefers, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            gp._panic = p.link</span><br><span class="line">            <span class="keyword">for</span> gp._panic != <span class="literal">nil</span> &amp;&amp; gp._panic.aborted &#123;</span><br><span class="line">                gp._panic = gp._panic.link</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> gp._panic == <span class="literal">nil</span> &#123; </span><br><span class="line">                gp.sig = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gp.sigcode0 = <span class="keyword">uintptr</span>(sp)</span><br><span class="line">            gp.sigcode1 = pc</span><br><span class="line">            mcall(recovery)</span><br><span class="line">            throw(<span class="string">&quot;recovery failed&quot;</span>) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们回到 <code>gopanic</code> 方法中再仔细看看，发现实际上是包含对 <code>recover</code> 流转的处理代码的。恢复流程如下：</p>
<ul>
<li>判断当前 <code>_panic</code> 中的 <code>recover</code> 是否已标注为处理</li>
<li>从 <code>_panic</code> 链表中删除已标注中止的 <code>panic</code> 事件，也就是删除已经被恢复的 <code>panic</code> 事件</li>
<li>将相关需要恢复的栈帧信息传递给 <code>recovery</code> 方法的 <code>gp</code> 参数（每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量）</li>
<li>执行 <code>recovery</code> 进行恢复动作</li>
</ul>
<p>从流程来看，最核心的是 <code>recovery</code> 方法。它承担了异常流转控制的职责。代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recovery</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    sp := gp.sigcode0</span><br><span class="line">    pc := gp.sigcode1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sp != <span class="number">0</span> &amp;&amp; (sp &lt; gp.stack.lo || gp.stack.hi &lt; sp) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recover: &quot;</span>, hex(sp), <span class="string">&quot; not in [&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;, &quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">        throw(<span class="string">&quot;bad recovery&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp.sched.sp = sp</span><br><span class="line">    gp.sched.pc = pc</span><br><span class="line">    gp.sched.lr = <span class="number">0</span></span><br><span class="line">    gp.sched.ret = <span class="number">1</span></span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粗略一看，似乎就是很简单的设置了一些值？但实际上设置的是编译器中伪寄存器的值，常常被用于维护上下文等。在这里我们需要结合 <code>gopanic</code> 方法一同观察 <code>recovery</code> 方法。它所使用的栈指针 <code>sp</code> 和程序计数器 <code>pc</code> 是由当前 <code>defer</code> 在调用流程中的 <code>deferproc</code> 传递下来的，因此实际上最后是通过 <code>gogo</code> 方法跳回了 <code>deferproc</code> 方法。另外我们注意到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gp.sched.ret = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在底层中程序将 <code>gp.sched.ret</code> 设置为了 1，也就是<strong>没有实际调用</strong> <code>deferproc</code> 方法，直接修改了其返回值。意味着默认它已经处理完成。直接转移到 <code>deferproc</code> 方法的下一条指令去。至此为止，异常状态的流转控制就已经结束了。接下来就是继续走 <code>defer</code> 的流程了。</p>
<p>为了验证这个想法，我们可以看一下核心的跳转方法 <code>gogo</code> ，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void gogo(Gobuf*)</span></span><br><span class="line"><span class="comment">// restore state from Gobuf; longjmp</span></span><br><span class="line">TEXT runtime·gogo(SB),NOSPLIT,$<span class="number">8</span><span class="number">-4</span></span><br><span class="line">    MOVW    buf+<span class="number">0</span>(FP), R1</span><br><span class="line">    MOVW    gobuf_g(R1), R0</span><br><span class="line">    BL    setg&lt;&gt;(SB)</span><br><span class="line"></span><br><span class="line">    MOVW    gobuf_sp(R1), R13    <span class="comment">// restore SP==R13</span></span><br><span class="line">    MOVW    gobuf_lr(R1), LR</span><br><span class="line">    MOVW    gobuf_ret(R1), R0</span><br><span class="line">    MOVW    gobuf_ctxt(R1), R7</span><br><span class="line">    MOVW    $<span class="number">0</span>, R11</span><br><span class="line">    MOVW    R11, gobuf_sp(R1)    <span class="comment">// clear to help garbage collector</span></span><br><span class="line">    MOVW    R11, gobuf_ret(R1)</span><br><span class="line">    MOVW    R11, gobuf_lr(R1)</span><br><span class="line">    MOVW    R11, gobuf_ctxt(R1)</span><br><span class="line">    MOVW    gobuf_pc(R1), R11</span><br><span class="line">    CMP    R11, R11 <span class="comment">// set condition codes for == test, needed by stack split</span></span><br><span class="line">    B    (R11)</span><br></pre></td></tr></table></figure>

<p>通过查看代码可得知其主要作用是从 <code>Gobuf</code> 恢复状态。简单来讲就是将寄存器的值修改为对应 <code>Goroutine(g)</code> 的值，而在文中讲了很多次的 <code>Gobuf</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type gobuf struct &#123;</span><br><span class="line">    sp   uintptr</span><br><span class="line">    pc   uintptr</span><br><span class="line">    g    guintptr</span><br><span class="line">    ctxt unsafe.Pointer</span><br><span class="line">    ret  sys.Uintreg</span><br><span class="line">    lr   uintptr</span><br><span class="line">    bp   uintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲道理，其实它存储的就是 <code>Goroutine</code> 切换上下文时所需要的一些东西。</p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    OPANIC       <span class="comment">// panic(Left)</span></span><br><span class="line">    ORECOVER     <span class="comment">// recover()</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        Dump(<span class="string">&quot;walk&quot;</span>, n)</span><br><span class="line">        Fatalf(<span class="string">&quot;walkexpr: switch 1 unknown op %+S&quot;</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ONONAME, OINDREGSP, OEMPTY, OGETG:</span><br><span class="line">    <span class="keyword">case</span> OTYPE, ONAME, OLITERAL:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> OPANIC:</span><br><span class="line">        n = mkcall(<span class="string">&quot;gopanic&quot;</span>, <span class="literal">nil</span>, init, n.Left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ORECOVER:</span><br><span class="line">        n = mkcall(<span class="string">&quot;gorecover&quot;</span>, n.Type, init, nod(OADDR, nodfp, <span class="literal">nil</span>))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上在调用 <code>panic</code> 和 <code>recover</code> 关键字时，是在编译阶段先转换为相应的 OPCODE 后，再由编译器转换为对应的运行时方法。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lirui-1997.github.io/">李瑞</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lirui-1997.github.io/2021/03/03/Golang%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3panic%E5%92%8Crecover/">https://lirui-1997.github.io/2021/03/03/Golang%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3panic%E5%92%8Crecover/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用  <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 </a> 许可协议。转载请注明出处！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a><a class="post-meta__tags" href="/tags/panic/">panic</a><a class="post-meta__tags" href="/tags/recover/">recover</a><a class="post-meta__tags" href="/tags/%E5%BC%82%E5%B8%B8/">异常</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/image/封面/微信图片_20200922105439.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/03/Golang%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/image/封面/微信图片_20200922105439.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Golang代码执行流程图</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/03/Go%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E4%B9%8BGPM%E6%A8%A1%E5%9E%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/image/封面/微信图片_20200922105439.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go进阶学习之GPM模型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/03/Golang代码执行流程图/" title="Golang代码执行流程图"><img class="cover" src="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/image/封面/微信图片_20200922105439.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-03</div><div class="title">Golang代码执行流程图</div></div></a></div><div><a href="/2021/03/04/golang面试总结/" title="golang面试总结"><img class="cover" src="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/image/封面/微信图片_20200922105439.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-04</div><div class="title">golang面试总结</div></div></a></div><div><a href="/2021/03/03/golang学习之进程、线程和协程/" title="golang学习之进程、线程和协程"><img class="cover" src="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/image/封面/微信图片_20200922105439.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-03</div><div class="title">golang学习之进程、线程和协程</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 李瑞</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/gh/LiRui-1997/hexo/StaticFile_Hexo-master/butterfly/js/pool.min.js"></script><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script></div></body></html>